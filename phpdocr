#!/usr/bin/ruby
# phpdocr
# Copyright (C) Eskild Hustvedt 2009
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Command-line parsing
require 'getoptlong'
# To run the prettifier
require 'open3'
# To create a temporary file with HTML
require 'tempfile'
# www-mechanize is used for fetching from HTTP
require 'rubygems'
require 'mechanize'
# Application version
$version = 0.1
# Bool, true if we should include the user notes section
$includeUserNotes = false

# Fetch a URL and return its contents
def getURL (url)
	begin
		www = WWW::Mechanize.new
		return www.get(url).body
	rescue
		return ''
	end
end

# Purpose: Check for a file in path
def inPath(exec)
	ENV['PATH'].split(/:/).each do |part|
		if File.executable?(part+'/'+exec) and not File.directory?(part+'/'+exec)
			return true
		end
	end
	return false
end

# Purpose: Detect and run a prettifier
def prettifier (path)
	[ 'elinks', 'links2', 'links' ].each do |links|
		if inPath(links)
			return [ links,'-force-html','-dump',path ]
		end
	end

	if inPath('html2text')
		return ['html2text','-style','pretty',path ]
	end

	if inPath('lynx')
		return ['lynx','-dump','-force_html',path ]
	end

	puts
	puts "Failed to locate any HTML parser. Please install one of the following,"
	puts "and then re-run phpdocr: elinks, links2, links, html2text, lynx"
	exit(1)
end

# Purpose: Parse an index list
def parseIndexList (list)
	result = ''

	rmlastA = false
	first = true

	list.split(/</).each do |line|
		if line =~ /^a href="\w/
			currlink = String.new(line)
			currlink.sub!(/^a href="/,'')
			currlink.sub!(/".*$/,'')
			currlink.sub!(/\.php$/,'')
			currlink.sub!(/^function/,'')
			line.sub!(/^[^>]+>/,'')
			line = String.new('[Link: '+currlink+'] '+line)
			rmlastA = true
		elsif line =~ /\/a>/ and rmlastA
			line.sub!(/^\/a>/,'')
			rmlastA = false
		elsif first
			first = false
		else
			line = '<'+line
		end
		result.concat(line)
	end
	return result
end

# Purpose: Attempt to fetch suggestions
def fetchSuggestions (data)
	final =  []
	hadStart = false
	no = 0
	data.split(/\n/).each do |line|
		if line =~ /result list start/
			hadStart = true
		elsif hadStart == false
			next
		elsif line =~ /result list end/
			break
		else
			no += 1
			line.gsub!(/<[^>]+>/,'')
			if line =~ /\S/
				final.push(line)
			end
		end
	end
	if hadStart && final != nil
		return final
	else
		return nil
	end
end

# Purpose: Look up something
def lookup (name, fetchPattern = true, prevSearch = nil)
	if fetchPattern == true
		url = 'http://php.net/manual-lookup.php?pattern='+name
	else
		exactName = String.new(name)
		if ! exactName =~ /\.php$/
			exactName.concat('.php')
		end
		url = 'http://php.net/manual/en/'+exactName+'.php'
	end
	data = getURL(url)
	hadFirst = false
	hadUDM = false
	result = ''
	indexResult = ''
	data.split(/\n/).each do |line|
		if hadFirst
			if ! $includeUserNotes && line =~ /User Contributed Notes/
				break
			end
			result.concat(line)
		elsif line =~ /ect1/
			hadFirst = true
		end
		if hadUDM
			if line =~ /<h1 class="title">/
				indexResult = String.new(line)
			else
				indexResult.concat(line)
			end
		elsif line =~ /UdmComment/
			hadUDM = true
		end
	end

	if ! hadFirst
		if hadUDM
			result = parseIndexList(indexResult)
		else
			if fetchPattern
				lookup(name,false,data)
			else
				puts
				puts 'Could not find '+name+' in PHP documentation'
				if prevSearch != nil
					suggest = fetchSuggestions(prevSearch)
					if suggest != nil
						puts "\n"
						puts "Perhaps you were looking for one of these?"
						while suggest.length > 0
							printf("%-20s %-20s %-20s %-20s\n",suggest[0],suggest[1],suggest[2],suggest[3])
							4.times { suggest.shift }
						end
						puts suggest
					end
				end
			end
			return
		end
	end

	tmp = Tempfile.new('phpdocr')
	tmp.puts('<html><body>'+result+'</body></html>')
	tmp.flush
	cmd = prettifier(tmp.path)
	Open3.popen3(*cmd) { |stdin, stdout, stderr|
		result = stdout.gets(nil)
	}

	tmp.close(true)

	result.concat("\nRetrieved from "+url)

	pager = ENV['PAGER']
	if pager == '' || pager == nil
		pager = 'less'
	end

	input = IO.popen(pager,'w')
	input.puts(result)
	input.close
end

if ARGV.length == 0 || ARGV.length > 1
	puts('USAGE: phpdocr [function|statement|operator|class]')
	exit(0)
end

lookup(ARGV.shift)
