#!/usr/bin/ruby
# phpdocr
# Copyright (C) Eskild Hustvedt 2009
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Fetch from rubygems if available
require 'rubygems'
# Command-line parsing
require 'getoptlong'
# To run the prettifier
require 'open3'
# To create a temporary file with HTML
require 'tempfile'
# CGI is used for escaping
require 'cgi'
# www-mechanize is used for fetching from HTTP
require 'mechanize'
# Application version
$version = 0.1
# Bool, true if we should include the user notes section
$includeUserNotes = false

# Fetch a URL and return its contents
def getURL (url)
	begin
		www = WWW::Mechanize.new
		return www.get(url).body
	rescue
		return ''
	end
end

# Purpose: Check for a file in path
def inPath(exec)
	ENV['PATH'].split(/:/).each do |part|
		if File.executable?(part+'/'+exec) and not File.directory?(part+'/'+exec)
			return true
		end
	end
	return false
end

# Purpose: Detect and run a prettifier
def prettifier (path)
	# Links family, all use the same syntax
	[ 'elinks', 'links2', 'links' ].each do |links|
		if inPath(links)
			return [ links,'-force-html','-dump',path ]
		end
	end

	# html2text
	if inPath('html2text')
		return ['html2text','-style','pretty',path ]
	end

	# Finally, try lynx
	if inPath('lynx')
		return ['lynx','-dump','-force_html',path ]
	end

	# If we found none, then give up
	puts
	puts "Failed to locate any HTML parser. Please install one of the following,"
	puts "and then re-run phpdocr: elinks, links2, links, html2text, lynx"
	exit(1)
end

# Purpose: Convert links
def convertLinks (list)
	result = ''

	rmlastA = false
	first = true

	list.split(/</).each do |line|
		if line =~ /^a href="\w/
			currlink = String.new(line)
			# Remove the href
			currlink.sub!(/^a href="/,'')
			# Remove whatever is after the href
			currlink.sub!(/".*$/,'')
			# Remove '#' links
			currlink.sub!(/#.*$/,'')
			# Parse away .php and function declarations
			currlink.sub!(/\.php$/,'')
			currlink.sub!(/^function\./,'')
			# Remove other HTML
			line.sub!(/^[^>]+>/,'')
			# Add new content
			line = String.new('['+currlink+'] '+line)
			rmlastA = true
		# Remove the a> if rmlastA is true
		elsif line =~ /\/a>/ and rmlastA
			line.sub!(/^\/a>/,'')
			rmlastA = false
		elsif first
			first = false
		else
			line = '<'+line
		end
		result.concat(line)
	end
	return result
end

# Purpose: Attempt to fetch suggestions
def fetchSuggestions (data)
	final =  []
	hadStart = false
	no = 0
	data.split(/\n/).each do |line|
		if line =~ /result list start/
			hadStart = true
		elsif hadStart == false
			next
		elsif line =~ /result list end/
			break
		else
			no += 1
			# Kill all HTML
			line.gsub!(/<[^>]+>/,'')
			if line =~ /\S/
				final.push(line)
			end
		end
	end
	if hadStart && final != nil
		return final
	else
		return nil
	end
end

# Purpose: Look up something
def lookup (name, fetchPattern = true, prevSearch = nil)
	# fetchPattern means we should run a serach
	stringC = String.new(name)
	if fetchPattern == true
		stringC = CGI.escape(name)
		url = 'http://php.net/manual-lookup.php?pattern='+name
	else
		# Otherwise, attempt a direct page
		if ! stringC =~ /\.php$/
			stringC.concat('.php')
		end
		url = 'http://php.net/manual/en/'+stringC+'.php'
	end
	# Retrieve data
	data = getURL(url)
	# True if this is within the normally returned page
	hadFirst = false
	# True if we have had the UDM statement
	hadUDM = false
	# The result on normal pages
	result = ''
	# The result on index-like pages
	indexResult = ''
	# Parse it
	data.split(/\n/).each do |line|
		if hadFirst
			if ! $includeUserNotes && line =~ /User Contributed Notes/
				break
			end
			result.concat(line)
		elsif line =~ /ect1/
			hadFirst = true
		end
		if hadUDM
			if line =~ /<h1 class="title">/
				indexResult = String.new(line)
			else
				indexResult.concat(line)
			end
		elsif line =~ /UdmComment/
			hadUDM = true
		end
	end

	# If we got no useful data, try again if possible, else output failure
	if ! hadFirst && ! hadUDM
		# If this was a fetchPattern run, try a direct one
		if fetchPattern
			lookup(name,false,data)
		else
			# This was a direct one, output errors
			puts
			puts 'Could not find '+name+' in PHP documentation'
			# If we have a previous search value, attempt to fetch suggestions from it
			if prevSearch != nil
				suggest = fetchSuggestions(prevSearch)
				# If we have suggestions, output them.
				if suggest != nil
					puts "\n"
					puts "Perhaps you were looking for one of these?"
					while suggest.length > 0
						printf("%-20s %-20s %-20s %-20s\n",suggest[0],suggest[1],suggest[2],suggest[3])
						4.times { suggest.shift }
					end
				end
			end
		end
		return
	end

	# If we 'hadFirst', then result contains what we want, otherwise use
	# indexResult
	if hadFirst
		result = convertLinks(result)
	else
		result = convertLinks(indexResult)
	end

	# Write the data to a temporary file so the prettifier can
	# read it there (not all of them support reading from STDIN)
	tmp = Tempfile.new('phpdocr')
	tmp.puts('<html><body>'+result+'</body></html>')
	tmp.flush
	cmd = prettifier(tmp.path)
	# Get the output
	Open3.popen3(*cmd) { |stdin, stdout, stderr|
		result = stdout.gets(nil)
	}

	# Close and remove the temporary file
	tmp.close(true)

	# Append the url we used to the result
	result.concat("\nRetrieved from "+url)

	# Detect the pager
	pager = ENV['PAGER']
	if pager == '' || pager == nil
		pager = 'less'
	end

	# Write data to the pager
	input = IO.popen(pager,'w')
	input.puts(result)
	input.close
end

if ARGV.length == 0 || ARGV.length > 1
	puts('USAGE: phpdocr [function|statement|operator|class]')
	exit(0)
end

lookup(ARGV.shift)
